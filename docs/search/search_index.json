{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+","tags":false},"docs":[{"location":"","text":"","title":"Home"},{"location":"#faq","text":"","title":"FAQ"},{"location":"#what-can-i-use-this-for","text":"<p>You should use this for anything \"Aiming\" based. Examples include silent aim and aimbot.</p>","title":"What can I use this for?"},{"location":"#why-should-i-use-this","text":"<p>Built in, there is \"patches\" for many games. This means it is very easy to make aiming scripts for many games. In addition, there is already pre-made features (e.g. FOV / Hit Chance) which allows you to create high-quality aiming scripts while minimising bugs and time taken.</p>","title":"Why should I use this?"},{"location":"#can-i-contribute","text":"<p>Of course, you can create pull requests for things such as Game Patches and additional features!</p>","title":"Can I contribute?"},{"location":"#can-i-use-this","text":"<p>You are allowed to use this, but you must credit me - asper the license agreement.</p>","title":"Can I use this?"},{"location":"#usage","text":"<p>Simply load the script like this: <pre><code>-- // Dependencies\nlocal Aiming = loadstring(game:HttpGet(\"https://raw.githubusercontent.com/Stefanuk12/Aiming/main/Load.lua\"))()(\"Module\")\n</code></pre></p>  <p>Warning</p> <p>Please use the loader, instead of directly using the module. In rare cases, load the game patch for the specific game - if you have to. This is because you miss out on the automatic patch apply!</p>","title":"Usage"},{"location":"#loading-specific-game-patches","text":"<p>Some games like <code>Rush Point</code> may have multiple place ids. In order to load the correct patch, you can set the second argument as the name of the patch you want. For example: <pre><code>-- // Dependencies\nlocal Aiming = loadstring(game:HttpGet(\"https://raw.githubusercontent.com/Stefanuk12/Aiming/main/Load.lua\"))()(\"Module\", \"RushPoint\")\n</code></pre></p>","title":"Loading Specific Game Patches"},{"location":"#what-does-the-first-argument-mean","text":"<p>The first argument is the type of module you want. There are two types - <code>NPC</code> and <code>Module</code>. <code>NPC</code> is specifically designed to work with NPCs (but it requires configuration) and <code>Module</code> is specifically for Players.</p>","title":"What does the first argument mean?"},{"location":"aiming/getclosesttargetparttocursor/","text":"<p>Gets closest target part of a character (or NPC) to your mouse location. This uses Aiming.Settings.TargetPart.</p>","title":"Aiming.GetClosestTargetPartToCursor"},{"location":"aiming/getclosesttargetparttocursor/#parameters","text":"Name Description Type Default     <code>Character</code> N/A <code>Instance&lt;Model&gt;</code> N/A","title":"Parameters"},{"location":"aiming/getclosesttargetparttocursor/#return","text":"<p><code>&lt;tuple&gt;</code></p>    Name Description Type     <code>Part</code> N/A <code>Instance&lt;BasePart&gt;</code>   <code>Position</code> N/A <code>Vector2</code>   <code>On Screen</code> N/A <code>boolean</code>   <code>Magnitude</code> N/A <code>number</code>","title":"Return"},{"location":"aiming/getclosesttocursor/","text":"<p>Gets the closest player (or NPC) along with part, position, and whether they are on screen. It then sets those variables to <code>Aiming.Selected</code></p>  <p>Note</p> <p>Do not call this function, use <code>Aiming.Selected</code> instead. This holds the data resulting in better performance in general as you are not calling the function many, many times.</p>","title":"Aiming.GetClosestToCursor"},{"location":"aiming/getclosesttocursor/#parameters","text":"Name Description Type Default     N/A N/A N/A N/A","title":"Parameters"},{"location":"aiming/getclosesttocursor/#return","text":"<p>nil</p>","title":"Return"},{"location":"aiming/selected/","text":"<p>This is a table that holds the data from <code>Aiming.GetClosestToCursor</code>. Use this to get that data, as it results in better performance because you are not calling that function.</p>","title":"Aiming.Selected"},{"location":"aiming/selected/#structure","text":"Name Description Type     <code>Instance</code> N/A <code>Instance&lt;Model&gt;</code>   <code>Part</code> N/A <code>Instance&lt;BasePart&gt;</code>   <code>Position</code> N/A <code>Vector2</code>   <code>OnScreen</code> N/A <code>boolean</code>","title":"Structure"},{"location":"aiming/settings/","text":"<p>This is a table that holds all of the settings, along with one function that allows you to get a setting.</p>","title":"Aiming.Settings"},{"location":"aiming/settings/#aimingsettingsget","text":"<p>This function allows you to get a setting.</p>","title":"Aiming.Settings.Get"},{"location":"aiming/settings/#parameters","text":"<p>This is a vararg, just input the path to the settings. For example: <code>\"HitChance\"</code> or <code>\"FOVSettings\", \"Enabled\"</code></p>","title":"Parameters"},{"location":"aiming/settings/#return","text":"<p><code>&lt;any&gt;</code> Setting</p>","title":"Return"},{"location":"aiming/settings/#structure","text":"Name Description Type     <code>Enabled</code> N/A <code>boolean</code>   <code>VisibleCheck</code> N/A <code>boolean</code>   <code>HitChance</code> N/A <code>number</code>   <code>TargetPart</code> N/A <code>string | string[]</code>   <code>RaycastIgnore</code> N/A <code>&lt;Instance[]&gt; function | Instance[]</code>   <code>FOVSettings</code> N/A <code>see below</code>   <code>Ignored</code> N/A <code>see below</code>","title":"Structure"},{"location":"aiming/settings/#fovsettings","text":"Name Description Type     <code>Circle</code> N/A <code>&lt;Drawing&gt; Circle</code>   <code>Enabled</code> N/A <code>boolean</code>   <code>Scale</code> <code>FOV</code> <code>number</code>   <code>Sides</code> N/A <code>number</code>   <code>Colour</code> N/A <code>Color3</code>","title":"FOVSettings"},{"location":"aiming/settings/#ignored","text":"Name Description Type     <code>Teams</code> N/A <code>&lt;Team: Team, TeamColor: Color3&gt;[]</code>   <code>IgnoreLocalTeam</code> N/A <code>boolean</code>   <code>Players</code> N/A <code>Instance&lt;Player&gt; | number</code>","title":"Ignored"},{"location":"aiming/signals/","text":"<p>Warning</p> <p>This is unfinished.</p>  <p>There are four signals, for usage please see the Signals documentation.</p>    Name Description     <code>InstanceChanged</code> N/A   <code>PartChanged</code> N/A   <code>PositionChanged</code> N/A   <code>OnScreenChanged</code> N/A","title":"Aiming.Signals"},{"location":"aiming/updatefov/","text":"<p>Updates the FOV Circle</p>","title":"Aiming.UpdateFOV"},{"location":"aiming/updatefov/#parameters","text":"Name Description Type Default     N/A N/A N/A N/A","title":"Parameters"},{"location":"aiming/updatefov/#return","text":"<p><code>&lt;Drawing&gt;</code> Circle</p>","title":"Return"},{"location":"examples/","text":"<p>Compatibility warning</p> <p>This will work on some games that purely use the Mouse's <code>Hit</code> and <code>Target</code> properties.</p>  <pre><code>-- // Load Aiming Module\nlocal Aiming = loadstring(game:HttpGet(\"https://raw.githubusercontent.com/Stefanuk12/Aiming/main/Load.lua\"))()()\nlocal AimingSelected = Aiming.Selected\nlocal AimingChecks = Aiming.Checks\n\n-- // Hook\nlocal __index\n__index = hookmetamethod(game, \"__index\", function(t, k)\n    -- // Check if it trying to get our mouse's hit or target\n    if (t:IsA(\"Mouse\") and (k == \"Hit\" or k == \"Target\")) then\n        -- // If we can use the silent aim\n        if (AimingChecks.IsAvailable()) then\n            -- // Vars\n            local TargetPart = AimingSelected.Part\n\n            -- // Return modded val\n            return (k == \"Hit\" and TargetPart.CFrame or TargetPart)\n        end\n    end\n\n    -- // Return\n    return __index(t, k)\nend)\n</code></pre>","title":"Index Example"},{"location":"examples/aimlock/","text":"<p>Note</p> <p>This is more of a script than an example. It works on many games such as Phantom Forces!</p>  <pre><code>loadstring(game:HttpGet(\"https://raw.githubusercontent.com/Stefanuk12/Aiming/documentation/Examples/AimLock.lua\"))()\n</code></pre> <p>Source</p>","title":"Aim Lock Example"},{"location":"examples/namecall/","text":"<p>Needed Changes</p> <p>Make sure you add the names of the calling scripts to the <code>CallingScripts</code> variable because what this does it set every <code>Ray</code>'s direction towards the <code>Selected Part</code>'s position.</p> <p>If we make it do this to every single <code>Ray</code>, it may break the game.</p> <p>Also, if it does not use <code>FindPartOnRayWithIgnoreList</code>, you need to change it accordingly.</p>  <pre><code>-- // Load Aiming Module\nlocal Aiming = loadstring(game:HttpGet(\"https://raw.githubusercontent.com/Stefanuk12/Aiming/main/Load.lua\"))()()\n\n-- // Services\nlocal Workspace = game:GetService(\"Workspace\")\n\n-- // Vars\nlocal AimingSelected = Aiming.Selected\nlocal AimingChecks = Aiming.Checks\nlocal CurrentCamera = Workspace.CurrentCamera\n\n-- // Configure this\nlocal CallingScripts = {\n    \"ScriptName\"\n}\n\n-- // Hook\nlocal __namecall\n__namecall = hookmetamethod(game, \"__namecall\", function(...)\n    -- // Vars\n    local args = {...}\n    local self = args[1]\n    local method = getnamecallmethod()\n    local callingscript = getcallingscript()\n\n    -- // Checks\n    if (not checkcaller() and method == \"FindPartOnRayWithIgnoreList\" and table.find(CallingScripts, callingscript.Name) and AimingChecks.IsAvailable()) then\n        -- // Vars\n        local Origin = args[2].Origin\n        local Destination = AimingSelected.Part.Position\n        local Direction = (Destination - Origin).Unit * 1000\n\n        -- // Set ray\n        args[2] = Ray.new(Origin, Direction)\n\n        -- // Return modified arguments\n        return __namecall(unpack(args))\n    end\n\n    -- // Return\n    return __namecall(...)\nend)\n</code></pre>","title":"Namecall Example"}]}